
<div>
  <div class="wrapper">
    <div class="row">
      <div class="col-12 col-md-5">
        <div class="item-summary">
          <article class="my-5">
            <div class="row">
              <div class="col-12">
                <!-- show base coin -->
                <!-- show like count -->
              </div>
              <div class="col-12">
                <img id="nftImage"/>
              </div>
            </div>
            <div class="my-5">
              <div class="accordion" id="accordion">
                <div class="accordion-item">
                  <h2 class="accordion-header" id="header-one">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseDescription" aria-expanded="true" aria-controls="collapseDescription">
                      <i class="bi bi-list-columns-reverse mr-4"></i>
                      &nbsp Description
                    </button>
                  </h2>
                  <div id="collapseDescription" class="accordion-collapse collapse show" aria-labelledby="header-one" data-bs-parent="#accordionExample">
                    <div class="accordion-body">

                    </div>
                  </div>
                </div>
                <div class="accordion-item">
                  <h2 class="accordion-header" id="header-two">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseProperties" aria-expanded="true" aria-controls="collapseProperties">
                      <i class="bi bi-tags-fill"></i>
                      &nbsp Properties
                    </button>
                  </h2>
                  <div id="collapseProperties" class="accordion-collapse collapse show" aria-labelledby="header-two" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                      <div class="row properties-grid justify-content-between"></div>
                    </div>
                  </div>
                </div>
                <div class="accordion-item">
                  <h2 class="accordion-header" id="header-two">
                    <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseDetails" aria-expanded="true" aria-controls="collapseDetails">
                      <i class="bi bi-info-square"></i>
                      &nbsp Details
                    </button>
                  </h2>
                  <div id="collapseDetails" class="accordion-collapse collapse show" aria-labelledby="header-two" data-bs-parent="#accordionExample">
                    <div class="accordion-body">
                      <div class="nft-detail">
                        Contract Address
                        <span id="contractAddressSpan"></span>
                      </div>
                      <div class="nft-detail">
                        Token ID
                        <span><%= tokenId %></span>
                      </div>
                      <div class="nft-detail">
                        Token Standard
                        <span id="ercTypeSpan"></span>
                      </div>
                      <div class="nft-detail">
                        Chain
                        <!-- HARD CODING. TODO Change -->
                        <span>Ethereum</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </article>
        </div>
      </div>
      <div class="col-12 col-md-7">
        <div class="item-detail">
          <div class="my-5">
            <div class="flex-between">
              Created by <a id="creatorNameLink" class="wallet-address-link"></a>
              <!-- creator name -->
              <!-- external link -->
              <div id="externalLinksDiv"></div>
            </div>
            <div class="item-name">
              <h1 id="nftNameH1">NFT name</h1>
              <div>
                <!-- owner button -->
                <button type="button" id="auctionEndBtn" class="btn btn-default btn-danger btn-outline d-none">
                  Auction End
                </button>
                <button type="button" id="moveSellPageBtn" class="btn btn-default btn-primary d-none" onclick="moveSellPage()">
                  Sell NFT
                </button>
                <button type="button" id="sellCancelBtn" class="btn btn-default btn-primary d-none">
                  Sell Cancel
                </button>
              </div>
            </div>
            <div class="item-owner" id="nftOwner">
              Owned by <a id="nftOwnerLink" class="wallet-address-link"></a>
            </div>
          </div>
          <div>
            <div id="viewCountsDiv" style="display:flex">
            </div>
          </div>
          <div class="my-5 d-none" id="marketItemInfoDiv">
            <div class="market-time-div">
              <div class="market-time-top-div">
                <div class="flex-vertical-box">
                  <div style="display: flex;">
                    <button id="marketSelectLeft" class="btn btn-outline-secondary" type="button">&#60</button>
                    <div class="current-count">
                      <span id="currentMarketCountSpan">1</span>
                    </div>
                    <button id="marketSelectRight" class="btn btn-outline-secondary" type="button">&#62</button>
                  </div>
                  <div>
                    <span id="marketRemainLabelSpan">Market ends at</span>
                  </div>
                  <div class="d-flex">
                    <div class="flex-vertical-box time-box-div">
                      <span id ="marketRemainDays" class="limit-time">00</span>
                      <span class="limit-time-label">Days</span>
                    </div>
                    <div class="flex-vertical-box time-box-div">
                      <span id ="marketRemainHours" class="limit-time">00</span>
                      <span class="limit-time-label">Hours</span>
                    </div>
                    <div class="flex-vertical-box time-box-div">
                      <span id ="marketRemainMinutes" class="limit-time">00</span>
                      <span class="limit-time-label">Minutes</span>
                    </div>
                    <div class="flex-vertical-box time-box-div">
                      <span id ="marketRemainSeconds" class="limit-time">00</span>
                      <span class="limit-time-label">Seconds</span>
                    </div>
                  </div>
                </div>
              </div>
              <div class="market-time-bottom-div">
                <div>Current Price</div>
                <div class="mt-2">
                  <span class="market-info-price">
                    <span id="marketPriceEth">0</span> ETH
                  </span>
                  ￦ <span id="marketPriceWon">0</span>
                </div>
                <div class="d-flex" style="gap:10px">
                  <button type="button" id="buyNowBtn" class="btn btn-modern btn-primary btn-arrow-effect-1 d-none" onclick="buyNow()">
                    Buy now <i class="fas fa-external-link-alt ms-2"></i>
                  </button>
                  <button type="button" id="offerBtn" class="btn btn-modern btn-primary btn-outline btn-arrow-effect-1 d-none" onclick="showModal('offer')">
                    Make offer
                  </button>
                </div>
              </div>
            </div>
          </div>
          <div class="my-5 d-none" id="auctionMarketItemInfoDiv">
            <div style="border-radius:10px;border:1px solid #e5e8eb;">
              <div style="padding:25px;">
                <div class="flex-vertical-box">
                  <div>
                    <span id="auctionRemainLabelSpan">Auction ends at</span>
                  </div>
                  <div class="d-flex">
                    <div class="flex-vertical-box" style="width: 100px;">
                      <span id ="remainDays" class="limit-time">00</span>
                      <span class="limit-time-label">Days</span>
                    </div>
                    <div class="flex-vertical-box" style="width: 100px;">
                      <span id ="remainHours" class="limit-time">00</span>
                      <span class="limit-time-label">Hours</span>
                    </div>
                    <div class="flex-vertical-box" style="width: 100px;">
                      <span id ="remainMinutes" class="limit-time">00</span>
                      <span class="limit-time-label">Minutes</span>
                    </div>
                    <div class="flex-vertical-box" style="width: 100px;">
                      <span id ="remainSeconds" class="limit-time">00</span>
                      <span class="limit-time-label">Seconds</span>
                    </div>
                  </div>
                </div>
              </div>
              <div style="border-top:1px solid #e5e8eb;padding:25px;background:#fbfdff;border-radius:0px 0px 10px 10px;">
                <div>
                  <div id="priceLabel">Current Price</div>
                  <div class="mt-2">
                    <span class="market-info-price">
                      <span id="marketPriceEth">0</span> ETH
                    </span>
                    ￦ <span id="marketPriceWon">0</span>
                  </div>
                  <div class="d-flex" style="gap:10px">
                    <button type="button" id="auctionBidBtn" class="btn btn-modern btn-primary btn-outline btn-arrow-effect-1 d-none" onclick="showModal('bid')">
                      Bid
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="my-5">
            <div class="accordion" id="accordion">
              <div class="accordion-item">
                <h2 class="accordion-header" id="header-one">
                  <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapsePrice" aria-expanded="true" aria-controls="collapsePrice">
                    <i class="bi bi-graph-up mr-4"></i>
                    &nbsp Price History
                  </button>
                </h2>
                <div id="collapsePrice" class="accordion-collapse collapse show" aria-labelledby="header-one" data-bs-parent="#accordionExample">
                  <div class="accordion-body">
                    <div id="priceHistoryDiv" class="d-none">
                      <canvas id="chart"></canvas>
                    </div>
                    <div id="noPriceHistoryDiv" class="">
                      <div class="div-flex-vh-center font-color-1">
                        <span class="my-4">
                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-clock" viewBox="0 0 16 16">
                            <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
                            <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
                          </svg>
                        </span>
                        <span>No events have occurred yet</span>
                        <span class="mb-4">Check back later.</span>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="my-5">
            <div class="accordion" id="accordion">
              <div class="accordion-item">
                <h2 class="accordion-header" id="header-one">
                  <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOffers" aria-expanded="true" aria-controls="collapseOffers">
                    <i class="bi bi-wallet-fill mr-4"></i>
                    &nbsp Current Offers
                  </button>
                </h2>
                <div id="collapseOffers" class="accordion-collapse collapse show" aria-labelledby="header-one" data-bs-parent="#accordionExample">
                  <div class="accordion-body">
                    <div class="offer-table-wrapper scroll-bar">
                      <table class="table" id="OffersTable">
                        <tr>
                          <th>Price(ETH)</th>
                          <th>KRW Price</th>
                          <th>Floor Difference</th>
                          <th>Expiration</th>
                          <th>From</th>
                          <th><!-- Button셀 -->　</th>
                        </tr>
                      </table>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="row my-5">
      <div class="col-12">
        <div class="accordion" id="accordion">
          <div class="accordion-item">
            <h2 class="accordion-header" id="header-one">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseActivity" aria-expanded="true" aria-controls="collapseActivity">
                <i class="bi bi-arrow-down-up"></i>
                &nbsp Item Activity
              </button>
            </h2>
            <div id="collapseActivity" class="accordion-collapse collapse show" aria-labelledby="header-one" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <div class="activity-table-wrapper scroll-bar">
                  <table class="table" id="itemActivityTable">
                    <tr>
                      <th>Event</th>
                      <th>From</th>
                      <th>To</th>
                      <th>Date</th>
                    </tr>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="row my-5">
      <div class="col-12">
        <div class="accordion" id="accordion">
          <div class="accordion-item">
            <h2 class="accordion-header" id="header-one">
              <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseMoreItems" aria-expanded="true" aria-controls="collapseMoreItems">
                <i class="bi bi-grid-3x2-gap-fill"></i>
                &nbsp More Items
              </button>
            </h2>
            <div id="collapseMoreItems" class="accordion-collapse collapse show" aria-labelledby="header-one" data-bs-parent="#accordionExample">
              <div class="accordion-body">
                <div class="row">

                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



<!-- modal -->
<div class="modal-popup-back div-flex-vh-center2 d-none" id="offerModal">
  <div class="card" style="max-width: 600px;">
    <div class="card-text m-4">
      <div class="div-vertical-center">
        <div class="row">
          <div class="col-1"></div>
          <div class="col-10">
            <h4>Make an Offer</h4>
          </div>
          <div class="col-1">
            <button type="button" class="btn-close" onclick="fn_modal_close()"></button>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-12">
          <h5>Price</h5>
          <div class="input-group">
            <input type="text" class="form-control set-price-input input-eth" placeholder="Price"  aria-describedby="basic-addon2" id="offerPriceInput"/>
            <span class="input-group-text set-price-span" id="basic-addon2">ETH</span>
          </div>
          <div class="mx-3 mb-3 input-info">
            <span class="d-none info-allow font-color-allow">
              <i class="bi bi-check-circle"></i>
            </span>
            <span class="d-none info-deny font-color-warn">
              <i class="bi bi-dash-circle"></i>
            </span>
            <span class="info-message font-color-warn"></span>
          </div>
        </div>
        <div class="col-12 mt-4 d-grid">
          <button type="button" class="btn btn-primary" onclick="makeOffer()">offer</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modal-popup-back div-flex-vh-center2 d-none" id="bidModal">
  <div class="card" style="max-width: 600px;">
    <div class="card-text m-4">
      <div class="div-vertical-center">
        <div class="row">
          <div class="col-1"></div>
          <div class="col-10">
            <h4>Bid the auction Item</h4>
          </div>
          <div class="col-1">
            <button type="button" class="btn-close" onclick="fn_modal_close()"></button>
          </div>
        </div>
      </div>
      <div class="row">
        <div class="col-12">
          <h5>Price</h5>
          <div class="input-group">
            <input type="text" class="form-control set-price-input input-eth" placeholder="Price" aria-describedby="basic-addon2" id="bidPriceInput"/>
            <span class="input-group-text set-price-span" id="basic-addon2">ETH</span>
          </div>
          <div class="mx-3 mb-3 input-info">
            <span class="d-none info-allow font-color-allow">
              <i class="bi bi-check-circle"></i>
            </span>
            <span class="d-none info-deny font-color-warn">
              <i class="bi bi-dash-circle"></i>
            </span>
            <span class="info-message font-color-warn"></span>
          </div>
        </div>
        <div class="col-12 mt-4 d-grid">
          <button type="button" class="btn btn-primary" onclick="auctionBid()">bid</button>
        </div>
      </div>
    </div>
  </div>
</div>


<!-- import chartjs -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- import decimaljs to show correct decimal -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/decimal.js/10.4.3/decimal.min.js"></script>
<!-- page script -->
<script>
  let contractTypeObj;
  const contractAddress = "<%= contractAddress %>"
  const tokenId = "<%= tokenId %>"
  const nftImage = document.getElementById("nftImage");
  const collapseDescription = document.getElementById("collapseDescription");
  const contractAddressSpan = document.getElementById("contractAddressSpan");
  const marketPriceEth = document.getElementById("marketPriceEth");
  const marketPriceWon = document.getElementById("marketPriceWon");
  const marketItemInfoDiv = document.getElementById("marketItemInfoDiv");
  const auctionMarketItemInfoDiv = document.getElementById("auctionMarketItemInfoDiv");
  const sellBtn = document.getElementById("moveSellPageBtn");
  const buyNowBtn = document.getElementById("buyNowBtn");
  const auctionBidBtn = document.getElementById("auctionBidBtn");
  const auctionEndBtn = document.getElementById("auctionEndBtn");
  const offerBtn = document.getElementById("offerBtn");
  const priceLabel = document.getElementById("priceLabel");
  const auctionRemainLabelSpan = document.getElementById("auctionRemainLabelSpan");
  const remainDays = document.getElementById("remainDays");
  const remainHours = document.getElementById("remainHours");
  const remainMinutes = document.getElementById("remainMinutes");
  const remainSeconds = document.getElementById("remainSeconds");
  const currentMarketCountSpan = document.getElementById("currentMarketCountSpan")
  const marketSelectLeft = document.getElementById("marketSelectLeft");
  const marketSelectRight = document.getElementById("marketSelectRight");
  const marketRemainDays = document.getElementById("marketRemainDays");
  const marketRemainHours = document.getElementById("marketRemainHours");
  const marketRemainMinutes = document.getElementById("marketRemainMinutes");
  const marketRemainSeconds = document.getElementById("marketRemainSeconds");
  const ercTypeSpan = document.getElementById("ercTypeSpan")
  let timeInterval;
  const SECOND = 1000
  const MINUTE = 1000 * 60;
  const HOUR = MINUTE * 60;
  const DAY = HOUR * 24;
  let ownerAddress, myNftCount, marketAddress, auctionAddress, erc721Address, erc1155Address;

  let priceChart;
  let offerDataArray = [];
  let marketDataIdArray = [];
  let currentMarketMataIndex = 0;
  let auctionDataIdArray = [];

  const moveSellPage = async () => {
    console.log("call moveSellPage")
    if(contractTypeObj.isERC721){
      if(compareAddress(ownerAddress, myWalletAddress)){
        window.location.href = window.location.origin + window.location.pathname + "/sell"
      } else {
        alert("소유자가 아닙니다.")
      }
    } else if(contractTypeObj.isERC1155){
      if(myNftCount > 0) {
        window.location.href = window.location.origin + window.location.pathname + "/sell"
      } else {
        alert("소유자가 아닙니다.")
      }
    }
  }
  const isOwner = () => {
    if(contractTypeObj.isERC721){
      return compareAddress(ownerAddress, myWalletAddress)
    } else if(contractTypeObj.isERC1155){
      return myNftCount > 0
    }
  }

  const fn_modal_open = (innerDom) => {
    const bodyDom = document.getElementsByTagName('body')[0];
    const offerModalDom = document.getElementById("offerModal");

    offerModalDom.classList.remove("d-none");
    bodyDom.classList.add("holding-body");
    offerModalDom.innerHTML = innerDom
  }

  const fn_modal_close = () => {
    const bodyDom = document.getElementsByTagName('body')[0];
    const offerModalDom = document.getElementById("offerModal");

    offerModalDom.classList.add("d-none");
    bodyDom.classList.remove("holding-body");
  }

  const buyNow = async (marketDataId) => {
    console.log("call buyNow")
    let priceEth = marketPriceEth.innerHTML;
    const successCallback = () => {
      window.location.reload()
    }
    const failureCallback = () => {
      fn_overlay_blindLoading(false)
      alert("구매 실패")
    }
    let option = getDefaultMethodOptionCallback("구매", successCallback, failureCallback)
    option.value = web3.utils.toWei(priceEth, "ether"),

    fn_overlay_blindLoading(true, "구매 진행중")
    await market_contract.buyMarketToken(marketDataId, option)
  }

  const showOfferModal = () => {
    const offerModal = document.getElementById("offerModal")
    fn_modal_open(offerModal.innerHTML);
  }

  const showModal = (type) => {
    let modalInnerHTML;
    if(type == "offer"){
      modalInnerHTML = document.getElementById("offerModal").innerHTML;
    } else if(type == "bid"){
      modalInnerHTML = document.getElementById("bidModal").innerHTML;
    } else {
      alert("error")
      return;
    }
    fn_modal_open(modalInnerHTML)
  }

  ////////////////////////////
  // market 함수
  ////////////////////////////
  const getSellingMarketDataId = async (contractAddress, tokenId) => {
    try {
      // Contract와 tokenId 기반으로 해당 NFT의 모든 판매시작내역을 가져옴
      const addedEventArray = await market_contract.getPastEvents({
        eventName: "MarketAdded",
        token: contractAddress,
        tokenId: tokenId
      })

      // 판매시작내역에 있는 dataId를 기반으로, 판매데이터를 조회
      const promises = addedEventArray.map(async (element, index)=> {
        return new Promise(async (resolve, reject) => {
          const marketData = await market_contract.marketDatas(element.returnValues.marketDataId)
          // 판매 데이터중 판매중인것만 resolve해줌
          if(!marketData.sold && !isNullAddress(marketData.seller)){
            resolve({marketDataId:element.returnValues.marketDataId, marketData})
          } else {
            reject()
          }
        })
      })

      const promiseResults = await Promise.allSettled(promises)
      const filteredResults = promiseResults.filter(e => e.status == "fulfilled")
      return filteredResults.map(e => e.value)
    } catch (error) {
      console.log("in getSellingMarketDataId error")
      console.log(error)
      throw error
    }
  }

  ////////////////////////////
  // auction 함수
  ////////////////////////////
  const getSellingAuctionDataId = async (contractAddress, tokenId) => {
    try {
      // Contract와 tokenId 기반으로 해당 NFT의 모든 경매시작, 종료내역을 가져옴
      // 경매는 중간에 취소가 되지 않기때문에 event로 처리
      const addedEventArray = await auction_contract.getPastEvents({
        eventName: "AuctionAdded",
        token: contractAddress,
        tokenId: tokenId
      })
      const endedEventArray = await auction_contract.getPastEvents({
        eventName: "AuctionEnded",
        token: contractAddress,
        tokenId: tokenId
      })

      addedItems = addedEventArray.map(e => e.auctionDataId)
      endedItems = endedEventArray.map(e => e.auctionDataId)

      return addedItems.filter(item => !endedItems.includes(item));
    } catch (error) {
      console.log("in getSellingMarketDataId error")
      console.log(error)
      throw error
    }
  }






  const auctionEnd = async () => {
    console.log("click auctionEnd")
    // TODO
    try {
      let option = {
        receipt: (receipt)=>{
          if(receipt.status) {
            console.log("Auction 종료를 완료했습니다.")
            window.location.reload()
          } else {
            console.log("Auction 종료를 실패했습니다.")
            console.log(receipt)
            console.warn(`receipt.status=${receipt.status}`)
            alert("Auction 실패")
          }
          fn_overlay_blindLoading(false)
        },
        error: (error, receipt)=>{
          console.log("event error")
          console.error(error)
          console.error(receipt)
          alert("Auction 실패")
          fn_overlay_blindLoading(false)
        }
      }
      fn_overlay_blindLoading(true, "Auction 종료중")
      await auction_contract.endAuctionItem(contractAddress, tokenId, option);
    } catch (error) {
      console.log(error)
      fn_overlay_blindLoading(false)
    }
  }
  auctionEndBtn.addEventListener("click", auctionEnd)
  const auctionBid = async () => {
    if(contractTypeObj.isERC721){
      if(compareAddress(myWalletAddress, ownerAddress)) {
        alert("You are nft owner. You can't do the offer")
        fn_modal_close()
        return ;
      }
    } else {
      // TODO. auctionData 조회 후, seller가 아닐때만 가능하게 처리
      if(myNftCount > 0){
        alert("You are nft owner. You can't do the offer")
        fn_modal_close()
        return ;
      } else {
        alert("You are nft owner. You can't do the offer")
        fn_modal_close()
        return ;
      }
    }
    // check input valid
    const bidPrice = document.getElementById("bidPriceInput").value;
    if(isValidEth(bidPrice)){
      let option = {
        value: web3.utils.toWei(bidPrice, "ether"),
        receipt: (receipt)=>{
          if(receipt.status) {
            console.log("bid가 완료되었습니다.")
            alert("bid 완료")
            setPriceLabel("auction", web3.utils.toWei(bidPrice.toString(), "ether"))
            fn_modal_close();
            window.location.reload()
          } else {
            console.log("bid가 실패되었습니다.")
            console.log(receipt)
            console.warn(`receipt.status=${receipt.status}`)
            alert("bid 실패")
          }
          fn_overlay_blindLoading(false)
        },
        error: (error, receipt)=>{
          console.log("event error")
          console.error(error)
          alert("bid 실패")
          fn_overlay_blindLoading(false)
        }
      }
      fn_overlay_blindLoading(true, "NFT auction에 bid 제출중")

      try {
        console.log("bidAuctionItem")
        await auction_contract.bidAuctionItem(contractAddress, tokenId, option)
      } catch (error) {
        console.error(error)
        fn_overlay_blindLoading(false);
      }
    }
  }
  const withdrawBid = async (bidCount) => {
    console.log("call withdrawBid, bidCount="+bidCount)
    try {
      const callback = () => {
        fn_overlay_blindLoading(false);
      }
      const label = "Bid금액 회수"
      const option = getDefaultMethodOption(label, callback);
      console.log(label)
      console.log(option)
      fn_overlay_blindLoading(true, `${label} 진행중`);
      await auction_contract.withdrawFromAuction(contractAddress, tokenId, bidCount, option)
    } catch (error) {
      console.log("withdraw Bid 실패.")
      console.log(error)
      fn_overlay_blindLoading(false);
    }
  }
  const makeOffer = async () => {
    let marketData = marketDataIdArray[currentMarketMataIndex];

    if(compareAddress(marketData.seller, myWalletAddress)){
      alert("You are nft owner. You can't do the offer")
      fn_modal_close()
      return ;
    }
    // check input valid
    const offerPrice = document.getElementById("offerPriceInput").value;
    const validPriceChecker = (value) => {
      return isValidEth(value)
    }

    // execute offer
    if(validPriceChecker(offerPrice)){
      const successCallback = () => {
        fn_modal_close();
        window.location.reload()
      }
      const failureCallback = () => {
        alert("offer 실패")
        fn_modal_close();
        fn_overlay_blindLoading(false)
      }
      let option = getDefaultMethodOptionCallback("offer", successCallback, failureCallback);
      option.value = web3.utils.toWei(offerPrice, "ether");

      try {
        fn_overlay_blindLoading(true, "NFT에 대한 offer 등록중")
        await market_contract.makeOffer(marketData.marketDataId, option)
      } catch (error) {
        console.error(error)
        fn_overlay_blindLoading(false);
      }
    } else {
      alert("Price or Duration is not valid")
    }
  }

  const cancelSell = async () => {
    let marketItemInfo = await market_contract.getMarketInfo(contractAddress, tokenId)
    if(marketItemInfo){
      var result = confirm("판매를 취소하시겠습니까?\n취소 시 Gas Fee가 소모됩니다.");
      if(result){
        let option = {
          receipt: (receipt)=>{
            if(receipt.status) {
              console.log("취소가 완료되었습니다.")
              alert("취소 완료")
              window.location.reload()
            } else {
              console.log("취소가 실패되었습니다.")
              console.log(receipt)
              console.warn(`receipt.status=${receipt.status}`)
              alert("취소 실패")
            }
            fn_overlay_blindLoading(false)
          },
          error: (error, receipt)=>{
            console.log("error발생")
            console.error(error)
            alert("취소 실패")
            fn_overlay_blindLoading(false)
          }
        }
        fn_overlay_blindLoading(true, "판매 취소중입니다.")
        await market_contract.cancelListedItem(contractAddress, tokenId, option)
      }
    }
  }
  const sellCancelBtn = document.getElementById("sellCancelBtn");
  sellCancelBtn.addEventListener("click", cancelSell)


  const setProperties = (array) => {
    const grid = document.getElementsByClassName("properties-grid")[0];
    grid.innerHTML = "";
    if(array){
      array.forEach(element => {
        let {trait_type, value} = element;

        let propertiesCol = document.createElement("div");
        propertiesCol.classList.add("col-4");
        propertiesCol.classList.add("py-2");
        propertiesCol.innerHTML = `
          <div class="properties-wrap">
            <div class="properties-type">${trait_type}</div>
            <div class="properties-value">${value}</div>
          </div>
        `
        grid.appendChild(propertiesCol);
      });
    }
  }
  const setItemActivity = async (transferEvents) => {
    // init Item Activity
    const itemActivityTable = document.getElementById("itemActivityTable")
    fn_table_DataClear("itemActivityTable")

    const getActivityAddressLink = (address) => {
      // market과 auction의 경우 Contract주소를 표시하는 것이 아니라 특정한 Label을 표시해준다.
      // 사용자만 사용자페이지로 연동하는 링크 설정
      if(compareAddress(address, defaultContractAddressObj[networkId].market)){
        let label = "Market Contract"
        return `<a class="cursor-pointer wallet-address-link" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="${label}">${label}</a>`;
      } else if(compareAddress(address, defaultContractAddressObj[networkId].auction)){
        let label = "Auction Contract"
        return `<a class="cursor-pointer wallet-address-link" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="${label}">${label}</a>`;
      } else {
        return `<a class="cursor-pointer wallet-address-link" onclick="openUserInfoPage('${address}')" data-bs-toggle="tooltip" data-bs-placement="top" data-bs-title="${address}">${maskingString(address)}</a>`;
      }
    }
    const addActivityDataToTable = (rowObj) => {
      let newRow = itemActivityTable.insertRow(-1);

      let eventCell = newRow.insertCell(-1);
      eventCell.innerHTML = isNullAddress(rowObj['from']) ? "Mint" : rowObj['event'];
      let fromCell = newRow.insertCell(-1);
      fromCell.innerHTML = getActivityAddressLink(rowObj['from'])
      let toCell = newRow.insertCell(-1);
      toCell.innerHTML = getActivityAddressLink(rowObj['to'])
      let dateCell = newRow.insertCell(-1);
      dateCell.innerHTML = rowObj['diffDate'];
    }

    if(transferEvents){
      let activityData = [];
      let promiseArray = transferEvents.map(async (element, index)=> {
        // 각 Activity 정보가 언제 있었는지 계산하기위해, Blockchain의 현재 시각을 얻어와야함
        // 비동기함수를 promise를 이용하여 동시에 처리하기위해서 array에 넣고 Promise All로 한번에 가져옴
        const tempBlock = await web3.eth.getBlock(element.blockNumber);

        // 시간차이 계산
        let diffObj = getTimeDiffAndUnit(new Date().getTime(), new Date(tempBlock.timestamp*1000).getTime())

        // Activity 테이블에 넣을 데이터 가공
        const rowData = {
          event: element.event,
          from: element.returnValues.from,
          to: element.returnValues.to,
          diffDate: new Intl.RelativeTimeFormat('ko-KR').format(diffObj.diff, diffObj.unit),
          datetime: new Date(tempBlock.timestamp*1000).getTime()
        };

        activityData.push(rowData);
      })

      await Promise.all(promiseArray).then(()=>{
        const sortData = (sort=-1) => {
          activityData.sort((a,b)=>{
            // return a[4] > b[4] ? -1 : 1;
            return a['datetime'] > b['datetime'] ? -1 : 1;
          })
          activityData.forEach(element => {
            addActivityDataToTable(element)
          });
        }
        sortData(-1)
      })
    }
  }
  const setPriceHistoryToChart = async (soldEvents) => {
    console.log("call setPriceHistoryToChart")
    console.log(soldEvents)
    const priceHistoryDiv = document.getElementById("priceHistoryDiv")
    const noPriceHistoryDiv = document.getElementById("noPriceHistoryDiv")
    const oneDaySeconds = 1000*60*60*24
    const removeLastZeros = (value) => {
      return value.replace(/(0+$)/, "")
    }
    const minimizeShowFloat = (value) => {
      const MAXIMUM_LENGTH = 18;
      const MINIMUM_LENGTH = 6

      let result = Number.parseFloat(value.toFixed(MAXIMUM_LENGTH)).toFixed(MINIMUM_LENGTH)
      return removeLastZeros(result);
    }
    const maximizeShowFloat = (value) => {
      const MAXIMUM_LENGTH = 18;
      const MINIMUM_LENGTH = 18;
      let result = Number.parseFloat(Number(value).toFixed(MAXIMUM_LENGTH)).toFixed(MINIMUM_LENGTH)
      return removeLastZeros(result);
    }

    // PriceData가 있는 경우에만
    if(soldEvents.length > 0){
      priceHistoryDiv.classList.remove("d-none")
      noPriceHistoryDiv.classList.add("d-none")
      let promiseArray = []
      soldEvents.forEach(element => {
        promiseArray.push(
          new Promise(async (resolve, reject) => {
            let blockData = await web3.eth.getBlock(element.blockNumber)
            switch (element.event) {
              case "MarketSold":
                resolve({type:"Market", amount: element.returnValues.amountOfToken, price:element.returnValues.price, date: new Date(blockData.timestamp*1000)})
                break;
              case "OfferAccept":
                resolve({type:"Offer", amount: element.returnValues.amountOfToken, price:element.returnValues.price, date: new Date(blockData.timestamp*1000)})
                break;
              case "AuctionEnded":
                resolve({type:"Auction", amount: element.returnValues.amountOfToken, price:element.returnValues.highestBid, date: new Date(blockData.timestamp*1000)})
                break;
              default:
                reject("no matching event in price chart");
                break;
            }
          })
        )
      });
      let itemDatas = await Promise.all(promiseArray)

      let labels=[], data=[];
      itemDatas.sort((a, b) => {
        return a.date < b.date ? -1 : 1;
      })
      itemDatas.forEach(element => {
        let tempLabel = [getYYYYMMDDStr(element.date), element.type]
        labels.push(tempLabel)
        data.push(web3.utils.fromWei(element.price, 'ether'))
      })

      let datasets = [{
        label: "ETH",
        data: data,
        fill: false,
        borderColor: 'rgba(0, 0, 0, 0.2)',
        borderWidth: 1,
        backgroundColor: '#86b7fe',
        pointBorderColor: '#86b7fe',
        pointBackgroundColor: '#86b7fe',
        pointBorderWidth: 4,
        pointRadius: 4,
        pointHitRadius: 8,
        pointHoverRadius: 8,
        tension: 0
      }]

      const ctx = document.getElementById("chart");
      if (priceChart !== undefined) {
        priceChart.destroy();
      }
      priceChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: labels,
          datasets: datasets
        },
        options: {
          scales: {
            x: {
              offset: true
            },
            y: {
              beginAtZero: true,
              ticks: {
                // stepSize: 0.001,
                callback: function(value, index, values) {
                  return `${minimizeShowFloat(value)}`
                },
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: "Trade Price"
            },
            subtitle: {
              display: true,
              text: "시간별 거래된 금액"
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  let dateLabel = context[0].label.split(",")[0];
                  return new Intl.DateTimeFormat('ko-KR').format(new Date(dateLabel))
                },
                label: function(context) {
                  let data = context.dataset.data[context.dataIndex]
                  let valueStr = data.toString()
                  return ` ${valueStr} ${context.dataset.label}`;
                  // return " " + removeLastZeros(maximizeShowFloat(data)) + " " + context.dataset.label
                },
              }
            }
          }
        }
      })
    } else {
      priceHistoryDiv.classList.add("d-none")
      noPriceHistoryDiv.classList.remove("d-none")
    }

  }
  const setCreatorLink = async (contractAddress, tokenId, external_url) => {
    const getCreatorLink = async (contractAddress, tokenId) => {
      // temp. DB구현 전까지 임시 리턴할 데이터
      return {discord: "url"};

      // TODO. DB에서 조회기능 구현
      const url = "";
      let fetchResponse = await fetch(url)
      if(fetchResponse.ok){
        let CreatorLinkData = await fetchResponse.json();
        return CreatorLinkData
      } else {
        console.error("setCreatorLink fetchResponse not ok")
        console.log(fetchResponse)
        return null;
      }
    }

    const externalLinksDiv = document.getElementById("externalLinksDiv");
    let { discord } = await getCreatorLink();

    let shareButton = `<button type="button" class="btn btn-outline-dark mx-1" onclick="copyUrlToClipboard()"><i class="bi bi-share-fill"></i></button>`
    let discordButton = `<button type="button" class="btn btn-outline-dark mx-1" onclick="javascript:window.location.href='${external_url}'"><i class="bi bi-discord"></i></button>`
    let websiteButton = `<button type="button" class="btn btn-outline-dark mx-1" onclick="javascript:window.location.href='${external_url}'"><i class="bi bi-globe2"></i></button>`
    let reportButton = `<button type="button" class="btn btn-outline-dark mx-1" onclick="javascript:console.log(1)"><i class="bi bi-flag-fill"></i></button>`

    externalLinksDiv.insertAdjacentHTML("beforeend", shareButton);
    if(external_url) externalLinksDiv.insertAdjacentHTML("beforeend", websiteButton);
    if(discord) externalLinksDiv.insertAdjacentHTML("beforeend", discordButton);
    externalLinksDiv.insertAdjacentHTML("beforeend", reportButton);

  }
  const copyUrlToClipboard = async () => {
    window.navigator.clipboard.writeText(window.location.href);
    alert('링크 주소가 복사되었습니다.')
  }
  const setViewCounts = async (contractAddress, tokenId) => {
    const getViewCounts = async (contractAddress, tokenId) => {
      const url = "";
      // temp
      return {viewCount: 31, likeCount: 5};

      // TODO. DB에서 데이터조회
      let fetchResponse = await fetch(url)
      if(fetchResponse.ok){
        let ViewCountsData = await fetchResponse.json();
        return ViewCountsData
      } else {
        console.error("setViewCounts fetchResponse not ok")
        console.log(fetchResponse)
        return null;
      }
    }

    const viewCountsDiv = document.getElementById("viewCountsDiv");
    let ViewCountsData = await getViewCounts(contractAddress, tokenId);
    viewCountsDiv.innerHTML = "";
    let viewDiv = document.createElement("div");
    viewDiv.classList.add("mx-1")
    viewDiv.insertAdjacentHTML("beforeend", `
      <span><i class="bi bi-eye"></i></span>
      <span>${ViewCountsData.viewCount}</span>
    `)
    let likeDiv = document.createElement("div");
    likeDiv.classList.add("mx-1")
    likeDiv.insertAdjacentHTML("beforeend", `
      <span><i class="bi bi-hand-thumbs-up"></i></span>
      <span>${ViewCountsData.likeCount}</span>
    `)
    ViewCountsData.likeCount;
    viewCountsDiv.append(viewDiv);
    viewCountsDiv.append(likeDiv);
  }
  const setApprove = (targetContract) => {
    return new Promise(async (resolve, reject) => {
      try {
        fn_overlay_blindLoading(true, "NFT 권한 이양 중")
        const approveOption = {
          receipt: ()=>{
            console.log("approve success")
            fn_overlay_blindLoading(false)
            resolve()
          },
          error: (error) => {
            console.log("approve error")
            console.log(error)
            fn_overlay_blindLoading(false);
            reject(error)
          }
        }
        await erc721_contract.approve(targetContract, tokenId, approveOption);
      } catch (error) {
        console.log("approve error")
        console.log(error)
        fn_overlay_blindLoading(false);
        reject(error)
      }
    })
  }
  const acceptOffer = async (offerIndex) => {
    console.log(`call acceptOffer ${offerIndex}`)
    // 권한 이양
    fn_overlay_blindLoading(true, "NFT 권한 확인 중")
    approveAddress = market_contract.getAddress();
    getApproved = await erc721_contract.getApproved(tokenId)
    if(!compareAddress(approveAddress, getApproved)) {
      console.log(`getApproved=${getApproved}`)
      await setApprove(approveAddress)
    }
    // offer 수락
    let findedOffer = offerDataArray.find(element => element.offerIndex == offerIndex)
    let option = {
      value: web3.utils.toWei(findedOffer.price, "ether"),
      receipt: (receipt)=>{
        if(receipt.status) {
          console.log("Offer 수락이 완료되었습니다.")
          alert("Offer 수락 완료")
          window.location.reload()
        } else {
          console.log("Offer 수락이 실패되었습니다.")
          console.log(receipt)
          console.warn(`receipt.status=${receipt.status}`)
          alert("Offer 수락 실패")
        }
        fn_overlay_blindLoading(false)
      },
      error: (error, receipt)=>{
        console.log("event error")
        console.error(error)
        alert("Offer 수락 실패")
        fn_overlay_blindLoading(false)
      }
    }
    fn_overlay_blindLoading(true, "제안된 가격에 Offer 수락 진행중")
    await market_contract.acceptOffer(contractAddress, tokenId, findedOffer.offerIndex, option)
  }
  const withdrawOffer = async (offerIndex) => {
    console.log(`call withdrawOffer ${offerIndex}`)
    let findedOffer = offerDataArray.find(element => element.offerIndex == offerIndex)
    let option = {
      receipt: (receipt)=>{
        if(receipt.status) {
          console.log("회수가 완료되었습니다.")
          alert("회수 완료")
          window.location.reload()
        } else {
          console.log("회수가 실패되었습니다.")
          console.log(receipt)
          console.warn(`receipt.status=${receipt.status}`)
          alert("회수 실패")
        }
        fn_overlay_blindLoading(false)
      },
      error: (error, receipt)=>{
        console.log("event error")
        console.error(error)
        alert("회수 실패")
        fn_overlay_blindLoading(false)
      }
    }
    fn_overlay_blindLoading(true, "제안한 금액 회수 진행중")
    console.log(contractAddress)
    console.log(tokenId)
    console.log(findedOffer.offerIndex)
    console.log(option)
    await market_contract.withdrawOutdatedOffer(contractAddress, tokenId, findedOffer.offerIndex, option)
  }
  const setPriceLabel = async (type, priceWei) => {
    priceLabel.innerHTML = type == "auction" ? "Highest Bid" : "Current Price"

    const eth = web3.utils.fromWei(priceWei, "ether");
    marketPriceEth.innerHTML = eth;

    let priceObj = await getCurrentMarketPriceObj("KRW-ETH");
    let wonPrice = priceObj.trade_price * eth;
    marketPriceWon.innerHTML = wonPrice.toLocaleString('ko-KR');
  }
  // offer history 조회
  const getOfferData = async (contractAddress, tokenId) => {
    const url = "";
    let offerEventArray = await market_contract.getPastEvents({eventName: "OfferItem", nft:contractAddress, tokenId: tokenId});
    if(offerEventArray.length > 0){
      let offerDataArray = [];
      const timeOption = {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric',
        hour: 'numeric',
        minute: 'numeric',
        second: 'numeric'
      }
      const priceObj = await getCurrentMarketPriceObj("KRW-ETH");

      let promiseArray = offerEventArray.map(async (element, index)=> {
        const _token = element.returnValues.token
        const _tokenId = element.returnValues.tokenId
        const _offerer = element.returnValues.offerer
        const _price = element.returnValues.price
        const _offerIndex = element.returnValues.offerIndex
        const _endTime = element.returnValues.endTime
        const offerDetail = await market_contract.getOfferDetail(_token, _tokenId, _offerIndex);

        // time difference
        let diffObj = getTimeDiffAndUnit(new Date().getTime(), new Date(_endTime*1000).getTime())
        let currentPriceETH = web3.utils.fromWei(_price, 'ether')
        console.log("offerDetail.remainPrice")
        console.log(offerDetail)
        if(offerDetail.remainPrice > 0){
          offerDataArray.push({
            price: _price,
            remainPrice: offerDetail.remainPrice,
            krwPrice: `￦ ${(priceObj.trade_price * currentPriceETH).toLocaleString('ko-KR')}`,
            floorDiff: "",
            // expiration: new Intl.DateTimeFormat('ko-KR', timeOption).format(element.endTime),
            expiration: "약 "+new Intl.RelativeTimeFormat('ko-KR').format(diffObj.diff, diffObj.unit),
            from: _offerer,
            targetTime: new Date(_endTime*1000).getTime(),
            offerIndex: _offerIndex
          })
        }
      })
      await Promise.all(promiseArray)

      return offerDataArray;
    } else {
      // TODO. ReferenceError: offersArray is not defined
      console.log("offerEventArray.length == 0")
      console.log(offerEventArray)
      return null;
    }
  }
  const setOffers = async (offerDataArray) => {
    const OffersTable = document.getElementById("OffersTable")
    // init table
    fn_table_Initialize("OffersTable")

    const addOfferData = async (rowData) => {
      let sort = -1
      let newRow = OffersTable.insertRow(sort);
      let priceCell = newRow.insertCell(sort);
      priceCell.innerHTML = web3.utils.fromWei(rowData["price"], 'ether')
      let krwPriceCell = newRow.insertCell(sort);
      krwPriceCell.innerHTML = rowData["krwPrice"];
      let floorDiffCell = newRow.insertCell(sort);
      floorDiffCell.innerHTML = rowData["floorDiff"];
      let expirationCell = newRow.insertCell(sort);
      expirationCell.innerHTML = rowData["expiration"];
      let fromCell = newRow.insertCell(sort);
      fromCell.innerHTML = maskingString(rowData["from"]);
      if(rowData["targetTime"] > new Date().getTime()){
        if(compareAddress(myWalletAddress, ownerAddress)){
          tempCell = newRow.insertCell(sort);
          tempCell.innerHTML = `<button class="btn btn-primary" onclick="acceptOffer(${rowData["offerIndex"]})">Accept</button>`
        }
      } else {
        if(compareAddress(myWalletAddress, rowData["from"])){
          if(Number(rowData["remainPrice"]) > 0){
            tempCell = newRow.insertCell(sort);
            tempCell.innerHTML = `<button class="btn btn-danger" onclick="withdrawOffer(${rowData["offerIndex"]}, ${rowData["remainPrice"]})">Withdraw</button>`
          }
        }
      }
    }


    let tempOfferDataArray = offerDataArray
    if(tempOfferDataArray) {
      tempOfferDataArray.sort((a,b)=>{
        return a.targetTime > b.targetTime ? -1 : 1;
      })
      tempOfferDataArray.forEach((element, index, array) => {
        addOfferData(element);
      });
    }
  }
  const setCreatorItem = (creatorOtherMintEvents) => {
    // creator의 다른 mintEvents를 가져와서 해당 nft를 제외하고 4개의 nft만 가져와서 세팅
    let moreItemsDiv = document.getElementById("collapseMoreItems").children[0].children[0];
    moreItemsDiv.innerHTML = "";

    const addCardItems = (contractAddress, tokenId, nftData) => {
      let colWrapper = document.createElement("div");
      colWrapper.classList.add('col-3');
      colWrapper.classList.add('my-2');
      colWrapper.classList.add('cursor-pointer');

      colWrapper.innerHTML = `
      <div class="card" style="width: 18rem;">
        <img class="card-img-top" src="${nftData.image}" style="max-height: 286px; object-fit: scale-down;"/>
        <div class="card-body">
          <h5 class="card-title">
            ${nftData.name}
          </h5>
          <p class="card-text">
            ${nftData.description}
          </p>
        </div>
      </div>
      `

      colWrapper.onclick = ()=>{
        window.location.href = window.location.origin + `/nft/${contractAddress}/${tokenId}`;
      }
      moreItemsDiv.append(colWrapper)
    }

    const addItemToMoreItems = async (contractAddress, tokenId) => {
      let nftData = await getMetadata(contractAddress, tokenId)
      addCardItems(contractAddress, tokenId, nftData)
    }

    for (let index = 0; index < creatorOtherMintEvents.length; index++) {
      if(index < 4 ) {
        // 4개만 표시
        let address, tokenId
        address = creatorOtherMintEvents[index].address;
        if(contractTypeObj.isERC721){
          tokenId = creatorOtherMintEvents[index].returnValues.tokenId
        } else {
          tokenId = creatorOtherMintEvents[index].returnValues.id
        }
        addItemToMoreItems(address, tokenId)
      } else {
        break;
      }
    }
  }

  const showAuctionBtn = (showBtnObj) => {
    const { auctionEnd, auctionBid } = showBtnObj;

    auctionEnd ? auctionEndBtn.classList.remove("d-none") : auctionEndBtn.classList.add("d-none")
    auctionBid ? auctionBidBtn.classList.remove("d-none") : auctionBidBtn.classList.add("d-none")
  }
  const showSellBtn = (showBtnObj) => {
    const { sell } = showBtnObj;
    sell ? sellBtn.classList.remove("d-none") : sellBtn.classList.add("d-none")
  }
  const showMarketBtn = (showBtnObj) => {
    const { hideAll, sellCancel, buyNow, offer } = showBtnObj;

    hideAll ? auctionMarketItemInfoDiv.classList.add("d-none") : auctionMarketItemInfoDiv.classList.remove("d-none")
    sellCancel ? sellCancelBtn.classList.remove("d-none") : sellCancelBtn.classList.add("d-none")
    buyNow ? buyNowBtn.classList.remove("d-none") : buyNowBtn.classList.add("d-none")
    offer ? offerBtn.classList.remove("d-none") : offerBtn.classList.add("d-none")
  }
  const calcDiffDate = (fromDate, toDate) => {
    let diff = toDate - fromDate;
    let remainDays = parseInt(diff / DAY);
    diff = diff % DAY;
    let remainHours = parseInt(diff / HOUR);
    diff = diff % HOUR;
    let remainMinutes = parseInt(diff / MINUTE);
    diff = diff % MINUTE;
    let remainSeconds = parseInt(diff / SECOND)
    return {
      remainDays,
      remainHours,
      remainMinutes,
      remainSeconds,
    }
  }
  const setRemainTimeLabel = (label, days, hours, minutes, seconds) => {
    console.log("call setRemainTimeLabel")
    auctionRemainLabelSpan.innerText = label;
    remainDays.innerText = days;
    remainHours.innerText = hours;
    remainMinutes.innerText = minutes;
    remainSeconds.innerText = seconds;
  }
  const setMarketRemainTimeLabel = (label, days, hours, minutes, seconds) => {
    console.log("call setMarketRemainTimeLabel")
    marketRemainLabelSpan.innerText = label;
    marketRemainDays.innerText = days;
    marketRemainHours.innerText = hours;
    marketRemainMinutes.innerText = minutes;
    marketRemainSeconds.innerText = seconds;
  }
  const setRemainTime = (startBlockDatetime, endBlockDatetime) => {
    console.log("call setRemainTime")
    // set interval
    if(!timeInterval){
      timeInterval = setInterval((startDatetime, endDatetime) => {
        let nowTimestamp = new Date().getTime();
        let targetTime, remainLabel;

        if(nowTimestamp < startDatetime){
          // start time
          targetTime = startDatetime;
          remainLabel = "Auction start after";
        } else if(nowTimestamp < endDatetime){
          // end time
          targetTime = endDatetime;
          remainLabel = "Auction end at";
        } else {
          // over time
          targetTime = endDatetime;
          remainLabel = "Auction ended";
          setRemainTimeLabel(remainLabel, 0, 0, 0, 0);

          // clear interval
          setTimeout(() => {
            clearInterval(timeInterval)
          }, 0);
          return;
        }

        let diff = targetTime - nowTimestamp;
        let remainDays = parseInt(diff / DAY);
        diff = diff % DAY;
        let remainHours = parseInt(diff / HOUR);
        diff = diff % HOUR;
        let remainMinutes = parseInt(diff / MINUTE);
        diff = diff % MINUTE;
        let remainSeconds = parseInt(diff / SECOND)

        setRemainTimeLabel(remainLabel, remainDays, remainHours, remainMinutes, remainSeconds);
      }, 1000, convertFromBlockTime(startBlockDatetime), convertFromBlockTime(endBlockDatetime));
    }
  }
  const setMarketAuctionPriceDiv = async (type, isSellerObj, priceWei, startBlockDatetime, endBlockDatetime) => {
    // isSellerObj = {isMarketSeller:Boolean, isAuctionSeller:Boolean, isOwner:Boolean}
    switch (type) {
      case "validAuction":
        auctionMarketItemInfoDiv.classList.remove("d-none")

        // 남은 시간 표시
        setRemainTime(startBlockDatetime, endBlockDatetime);
        // Current Price를 Highest Bid로 바꾸고 값 표시.
        setPriceLabel("auction", priceWei)

        const nowTime = new Date().getTime();
        const auctionEndTime = getDateFromBlocktime(endBlockDatetime).getTime();
        const auctionStartTime = getDateFromBlocktime(startBlockDatetime).getTime();
        if(nowTime < auctionStartTime){
          showMarketAuctionBtn({})
        } else if(nowTime < auctionEndTime){
          if(isSellerObj.isAuctionSeller){
            showMarketAuctionBtn({})
          } else {
            showMarketAuctionBtn({auctionBid: true})
          }
        } else {
          if(isSellerObj.isAuctionSeller){
            showMarketAuctionBtn({auctionEnd: true})
          } else {
            showMarketAuctionBtn({})
          }
        }
        break;
      case "validMarket":
        auctionMarketItemInfoDiv.classList.remove("d-none")
        setPriceLabel("market", priceWei)
        if(isSellerObj.isMarketSeller){
          showMarketAuctionBtn({sellCancel: true})
        } else {
          showMarketAuctionBtn({buyNow: true})
        }
        break;

      case "invalidMarket":
        // 과거 마켓이력이 있는 경우
        auctionMarketItemInfoDiv.classList.remove("d-none")
        setPriceLabel("market", priceWei)
        if(isSellerObj.isOwner){
          showMarketAuctionBtn({sell: true})
        } else {
          showMarketAuctionBtn({offer: true})
        }
        break;
      default:
        // 아무 정보가 없는 경우, 해당 div 자체를 숨김
        showMarketAuctionBtn({hideAll: true})
        break;
    }
  }
  ////////////////////////////
  // auction 이벤트 구독 시작
  ////////////////////////////
  let currentHighestBid = 0;
  let bidSubscriptionId, endSubscriptionId;

  const connectAuctionEvent = async () => {
    // connectAuctionEvent의 경우, auction이 끝나지 않은 상황에서만 호출이 되어야 함.
    // AuctionBided 이벤트 구독
    auction_contract.getInstance().events.AuctionBided({
      filter: {
        nft: contractAddress,
        tokenId: tokenId
      }
    }).on('data', (event) => {
      const bidder = event.returnValues.bidder;
      const bid = parseInt(event.returnValues.bid);

      if (bid > currentHighestBid) {
        currentHighestBid = bid;
        console.log(`New highest bid: ${bid} from ${bidder}`);
        // TODO
        // 최고가 바꿔주기.
      }
    }).on('error', console.error)
      .on('connected', (subscriptionId) => {
        console.log(`Subscribed to AuctionBided event with subscription ID: ${subscriptionId}`);
        bidSubscriptionId = subscriptionId;
    });

    // AuctionEnded 이벤트 구독
    auction_contract.getInstance().events.AuctionEnded({
      filter: {
        nft: contractAddress,
        tokenId: tokenId
      }
    }).on('data', (event) => {
      console.log(`Auction ended for NFT ${contractAddress} with ID ${tokenId}.`);
      console.log(`Highest bidder: ${event.returnValues.highestBidder}`);
      console.log(`Highest bid: ${event.returnValues.highestBid}`);

      // AuctionBided 이벤트 구독 취소
      web3.eth.clearSubscriptions(bidSubscriptionId);
      // AuctionEnded 이벤트 구독 취소
      web3.eth.clearSubscriptions(endSubscriptionId);

    }).on('error', console.error)
      .on('connected', (subscriptionId) => {
        console.log(`Subscribed to AuctionEnded event with subscription ID: ${subscriptionId}`);
        endSubscriptionId = subscriptionId;
      });
  }
  ////////////////////////////
  // auction 이벤트 구독 끝
  ////////////////////////////
  const getMetadata = async (contractAddress, tokenId) => {
    let metadataURI
    if(contractTypeObj.isERC721){
      metadataURI = await erc721_contract.tokenURI(tokenId);
    } else {
      metadataURI = await erc1155_contract.uri(tokenId);
    }

    let fetchResponse = await fetch(metadataURI)
    if(fetchResponse.ok){
      return await fetchResponse.json();
    } else {
      console.log("Metadata load error")
      throw `Metadata load error. \n contractAddress=${contractAddress}\n tokenId=${tokenId}`
    }
  }

  const setNFTdata = async (metadata) => {
    // Token Standard 표기.
    ercTypeSpan.innerText = contractTypeObj.isERC721 ? ERC721 : ERC1155;

    // init NFT image
    nftImage.src = metadata.image;

    // init NFT description
    collapseDescription.children[0].innerHTML = metadata.description

    // init NFT Properties
    setProperties(metadata.attributes);

    // init details
    contractAddressSpan.innerHTML = `
      <a class="cursor-pointer wallet-address-link" onclick="openEtherscan('contract', '${contractAddress}')">
        ${maskingString(contractAddress)}
      </a>
    `

    let nftNameH1 = document.getElementById("nftNameH1");
    nftNameH1.innerHTML = metadata.name;

    // init externalLink
    // console.log(`link=${data.external_url}`);
  }

  const getContractTransferEvent = async () => {
    let transferEvents = [];
    if(contractTypeObj.isERC721){
      // Transfer 이벤트는 from과 id 둘 다 검색 가능하기때문에 tokenId도 걸러준다.
      let eventTransfer = await erc721_contract.getPastEvents({eventName: "Transfer", tokenId: tokenId});
      transferEvents.push(...eventTransfer);
    } else {
      // TransferSingle, Batch Event는 operator, from, to만 검색가능하기에 filter함수로 걸러준다.
      let eventSingle = await erc1155_contract.getPastEvents({eventName: "TransferSingle"});
      let eventBatch = await erc1155_contract.getPastEvents({eventName: "TransferBatch"});
      eventSingle = eventSingle.filter(e => e.returnValues.id == tokenId)
      eventBatch = eventBatch.filter(e => e.returnValues.id == tokenId)
      transferEvents.push(...eventSingle);
      transferEvents.push(...eventBatch);
    }
    return transferEvents
  }

  const getMintEventFromTransferEvent = async (transferEvents) => {
    // from 데이터가 Null인 경우는 Mint인 경우
    let mintEvents = transferEvents.filter(e => e.returnValues.from == NULL_ADDRESS);
    return mintEvents
  }

  const setCreatorFromMintEvent = (mintEvents) => {
    // mint 이벤트에는 최초 수령받은 (nft를 창작한) 사람의 지갑주소가 있음.
    const creator = getCreatorAddress(mintEvents)

    // setCreator to span;
    const nftCreatorLink = document.getElementById("creatorNameLink");
    nftCreatorLink.href = window.location.origin + `/user/${creator}`;
    nftCreatorLink.innerHTML = maskingString(creator)
  }

  const setNFTOwnerDiv = async (ownerAddress, count) => {
    if(ownerAddress){
      nftOwner.innerHTML = `
        Owned by <a class="wallet-address-link" href='${window.location.origin}/user/${ownerAddress}'>${maskingString(ownerAddress)}</a>
      `
    } else if(count){
      nftOwner.innerHTML = `You have ${count}`
    }
  }

  const getSoldEvents = async () => {
    const itemSoldEvents = [];
    let marketSolds = await market_contract.getPastEvents({
      eventName: "MarketSold",
      token: contractAddress,
      tokenId: tokenId
    })
    let marketOfferAccept = await market_contract.getPastEvents({
      eventName: "OfferAccept",
      token: contractAddress,
      tokenId: tokenId
    })
    let auctionEnded = await auction_contract.getPastEvents({
      eventName: "AuctionEnded",
      token: contractAddress,
      tokenId: tokenId
    })
    itemSoldEvents.push(...marketSolds)
    itemSoldEvents.push(...marketOfferAccept)
    itemSoldEvents.push(...auctionEnded)

    return itemSoldEvents;
  }

  const getCreatorAddress = (mintEvents) => {
    const creator = mintEvents[0].returnValues.to;
    return creator;
  }

  const getCreatorOtherMintEvents = async (creatorAddress) => {
    // 해당 NFT Contract에서 creator Address기반으로 Mint된 토큰을 모두 불러온다.
    let mintEvents = [];
    if(contractTypeObj.isERC721){
      // Transfer 이벤트는 from과 id 둘 다 검색 가능하기때문에 tokenId도 걸러준다.
      let eventTransfer = await erc721_contract.getPastEvents({eventName: "Transfer", from:NULL_ADDRESS, to:creatorAddress});
      mintEvents.push(...eventTransfer);
      mintEvents = mintEvents.filter(e => e.returnValues.tokenId != Number(tokenId))
    } else {
      let eventSingle = await erc1155_contract.getPastEvents({eventName: "TransferSingle", from:NULL_ADDRESS, to:creatorAddress});
      let eventBatch = await erc1155_contract.getPastEvents({eventName: "TransferBatch", from:NULL_ADDRESS, to:creatorAddress});
      mintEvents.push(...eventSingle)
      mintEvents.push(...eventBatch)
      mintEvents = mintEvents.filter(e => e.returnValues.id != Number(tokenId))
    }
    return mintEvents.slice(0,4);
  }

  const setMarketButton = async (marketArrayInfo) => {
    let marketData = marketArrayInfo?.marketData;
    let marketDataId = marketArrayInfo?.marketDataId;
    let isMarketSeller;
    if(marketData){
      isMarketSeller = compareAddress(marketData.seller, myWalletAddress)
      // 마켓관련 버튼 보여주기
      // seller면 sellCancelBtn 아니면 buyNowBtn
      // data가 있으면 offer 버튼
      showMarketBtn({
        sellCancel: isMarketSeller,
        buyNow: !isMarketSeller,
        offer: !isMarketSeller
      })
    } else {
      showMarketBtn({})
    }
  }

  marketSelectLeft.addEventListener("click", ()=>{
    let index = currentMarketCountSpan.innerText - 1;
    setMarketData(index-1)
  })
  marketSelectRight.addEventListener("click", ()=>{
    let index = currentMarketCountSpan.innerText - 1;
    setMarketData(index+1)
  })

  const setMarketData = async (marketDataIndex=0) => {
    if(marketDataIdArray && (marketDataIdArray?.length-1) >= marketDataIndex ){
      marketItemInfoDiv.classList.remove("d-none")
      const marketData = marketDataIdArray[marketDataIndex].marketData;
      const marketDataId = marketDataIdArray[marketDataIndex].marketDataId;

      // span 현재 marketData 순서 표시
      currentMarketCountSpan.innerText = marketDataIndex+1;

      // "<" ">" 버튼 표시
      if(marketDataIdArray.length == 1){
        // 버튼 disabled로 표시
        marketSelectLeft.setAttribute("disabled", true);
        marketSelectRight.setAttribute("disabled", true);
      } else {
        // 1개 이상인경우
        if(marketDataIndex=0) marketSelectLeft.setAttribute("disabled", true);
        if(marketDataIndex==marketDataIdArray.length-1) marketSelectRight.setAttribute("disabled", true);
      }

      // MarketTime 표시
      let label, diffObj;
      let currentDate = new Date();
      let startDate = new Date(marketData.startAt * 1000);
      let endDate = new Date(marketData.endAt * 1000);
      if(startDate > currentDate) {
        label = "Market start at"
        diffObj = calcDiffDate(currentDate, startDate)
      } else if(endDate > currentDate){
        label = "Market end at"
        diffObj = calcDiffDate(currentDate, endDate)
      } else {
        label = "Market is over"
        diffObj = {
          days: 0,
          hours: 0,
          minutes: 0,
          seconds: 0,
        }
      }
      setMarketRemainTimeLabel(label, diffObj.days, diffObj.hours, diffObj.minutes, diffObj.seconds)

      // Current Price ETH 표시
      let ethPrice = web3.utils.fromWei(marketData.pricePerPiece);
      marketPriceEth.innerHTML = ethPrice;
      // Current Price KRW 표시
      let priceObj = await getCurrentMarketPriceObj("KRW-ETH");
      let wonPrice = priceObj.trade_price * ethPrice;
      marketPriceWon.innerHTML = wonPrice.toLocaleString('ko-KR');

      // Offer 데이터 표시
      // setOffers(offerDataArray);

      // offer Count 얻기
      const offerDataIndex = market_contract.offerCount(marketDataIndex)
      setOfferData(offerDataIndex)
    } else {
      // 마켓 데이터가 없는 경우 안보이게 표시
      marketItemInfoDiv.classList.add("d-none")
    }
  }
  const setOfferData = (offerDataIndex) => {

  }

  const loadNFTInfo = async function(){
    if(web3.utils.isAddress(contractAddress)){
      // 기본주소가 아닌 URI를 통해 접속된 Contract 주소로 contract 재생성.
      // erc721_contract = new NftContract721Wrapper(contractAddress, myWalletAddress);
      // erc1155_contract = new NftContract1155Wrapper(contractAddress, myWalletAddress);
      erc721_contract = await contractClassDecorator(BasicERC721ContractWrapper, contractAddress, ERC721_CONTRACT_ABI);
      erc1155_contract = await contractClassDecorator(BasicERC1155ContractWrapper, contractAddress, ERC1155_CONTRACT_ABI);

      // ERC Contract의 타입을 얻어옴 사용예) obj.isERC1155
      contractTypeObj = await getContractTypeObj(erc721_contract);
      console.log(contractTypeObj)

      const metadata = await getMetadata(contractAddress, tokenId);
      setNFTdata(metadata)

      const transferEvents = await getContractTransferEvent();
      setItemActivity(transferEvents)

      const mintEvents = await getMintEventFromTransferEvent(transferEvents);
      setCreatorFromMintEvent(mintEvents)

      const creatorAddress = getCreatorAddress(mintEvents)
      const creatorOtherMintEvents = await getCreatorOtherMintEvents(creatorAddress);
      setCreatorItem(creatorOtherMintEvents)

      if(contractTypeObj.isERC721){
        ownerAddress = await erc721_contract.ownerOf(tokenId)
      } else {
        myNftCount = await erc1155_contract.balanceOf(myWalletAddress, tokenId);
      }
      await setNFTOwnerDiv(ownerAddress, myNftCount);

      // 차트 데이터 조회
      const soldEvents = await getSoldEvents();
      setPriceHistoryToChart(soldEvents);

      showSellBtn({sell:isOwner()})

      ////////////////////////
      // Market 처리
      ////////////////////////
      // 마켓 데이터 조회
      const sellingMarketDataIdArray = await getSellingMarketDataId(contractAddress, tokenId)
      marketDataIdArray = sellingMarketDataIdArray
      console.log("sellingMarketDataIdArray=")
      console.log(sellingMarketDataIdArray)

      // 조회된 마켓 데이터 중 첫번째값으로 데이터 표시
      if(marketDataIdArray){
        setMarketButton(marketDataIdArray[0])
        currentMarketMataIndex = 0;
        setMarketData(currentMarketMataIndex)
      } else {
        setMarketButton();
      }


      // marketDataId별로 리스트 생성, 첫번째 리스트 정보 표시
      // TODO. 리스트 클릭, market정보 표시, 하위 offer리스트 표시

      // 경매 데이터 조회
      const sellingAuctionDataIdArray = await getSellingAuctionDataId(contractAddress, tokenId)
      console.log("sellingAuctionDataIdArray=")
      console.log(sellingAuctionDataIdArray)
      // auctionDataId 별 리스트 생성, 첫번째 리스트 정보 표시
      // TODO. 리스트 클릭, auction정보 표시, Bid버튼 표시



      // // TODO. Link 세팅 from db
      // setCreatorLink(contractAddress, tokenId, nftData.external_url);

      // // Offers 세팅. 마켓이후
      // TODO. Offer가 각 market에 올라온 아이템 기준으로 하위에 생성되므로 기존 방식 사용불가.
      // const offerDataArray = await getOfferData(contractAddress, tokenId)
      // setOffers(offerDataArray);

      // // TODO. View count 세팅 from db
      // setViewCounts(contractAddress, tokenId);

      // Market 버튼 세팅 ERC1155관련으로 새로 제작필요
      // let marketItemInfo = await market_contract.getMarketInfo(contractAddress, tokenId)
      // let auctionCurrentCount = await auction_contract.getAuctionCurrentCount(contractAddress, tokenId)
      // let auctionInfo = await auction_contract.getItemInfoOnAuction(contractAddress, tokenId, auctionCurrentCount)

      return ;
    } else {
      alert(`Contract Address is not valid. contract address = ${contractAddress}`);
    }
  }

  afterInitFunction = async function(){
    await loadNFTInfo();
  }
</script>
<style>
.accordion{
  --bs-accordion-color: var(--bs-body-color);
  --bs-accordion-bg: #fff;
  --bs-accordion-transition: color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out,border-radius 0.15s ease;
  --bs-accordion-border-color: var(--bs-border-color);
  --bs-accordion-border-width: 1px;
  --bs-accordion-border-radius: 0.375rem;
  --bs-accordion-inner-border-radius: calc(0.375rem - 1px);
  --bs-accordion-btn-padding-x: 1.25rem;
  --bs-accordion-btn-padding-y: 1rem;
  --bs-accordion-btn-color: var(--bs-body-color);
  --bs-accordion-btn-bg: var(--bs-accordion-bg);
  --bs-accordion-btn-icon: url(data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='var%28--bs-body-color%29'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3e%3c/svg%3e);
  --bs-accordion-btn-icon-width: 1.25rem;
  --bs-accordion-btn-icon-transform: rotate(-180deg);
  --bs-accordion-btn-icon-transition: transform 0.2s ease-in-out;
  --bs-accordion-btn-active-icon: url(data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16' fill='%230c63e4'%3e%3cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3e%3c/svg%3e);
  --bs-accordion-btn-focus-border-color: #86b7fe;
  --bs-accordion-btn-focus-box-shadow: 0 0 0 0.25rem rgba(13, 110, 253, 0.25);
  --bs-accordion-body-padding-x: 1.25rem;
  --bs-accordion-body-padding-y: 1rem;

  --bs-accordion-active-color: #000 !important;
  --bs-accordion-active-bg: #fff !important;
}
.market-info-price {
  font-size:30px;font-weight:bold;color:#000
}
.limit-time {
  margin-top: 10px;
  font-size: 1.2rem;
  font-weight: 600;
  color: #333333;
}
.limit-time-label {
  font-size: 1rem;
  color: #444444;
}
.offer-table-wrapper {
  width: 100%;
  height: 300px;
  overflow: auto;
}
.activity-table-wrapper {
  width: 100%;
  height: 500px;
  overflow: auto;
}
.market-time-div{
  border-radius:10px;
  border:1px solid #e5e8eb;
}
.market-time-top-div {
  padding:25px;
  background:#fbfdff;
  border-radius:10px 10px 0px 0px;
}
.market-time-bottom-div {
  border-top:1px solid #e5e8eb;
  padding:25px;
  background:white;
  border-radius:0px 0px 10px 10px;
}
.time-box-div {
  width: 100px;
}
.current-count{
  width: 34px;
  align-items: center;
  display: flex;
  justify-content: center;
}
</style>
